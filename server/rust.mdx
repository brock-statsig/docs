---
title: Legacy Rust Server SDK
sidebarTitle: Legacy Rust
description: Statsig's Legacy Server SDK for Rust applications
icon: "rust"
---

[Github Repository](https://github.com/statsig-io/rust-sdk)

## Installation

To use the SDK, add `statsig` as a dependency in your `Cargo.toml`. The latest version can be found at [crates.io/crates/statsig](https://crates.io/crates/statsig).

```toml
[dependencies]
statsig = "X.Y.Z" # <- update version
```

## Initialize the SDK

After installation, you will need to initialize the SDK using a [Server Secret Key from the Statsig console](https://console.statsig.com/api_keys).

<Warning>
Do NOT embed your Server Secret Key in client-side applications, or expose it in any external-facing documents. However, if you accidentally expose it, you can create a new one in the Statsig console.
</Warning>

```rust
use statsig::{Statsig};

Statsig::initialize("secret-key").await;

// or with StatsigOptions

use statsig::{Statsig, StatsigOptions};

let env = HashMap::from([("tier".to_string(), "staging".to_string())]);
let opts = StatsigOptions {
    environment: Some(env),
    ..StatsigOptions::default()
};

Statsig::initialize_with_options("secret-key", opts).await;
```

## Working with the SDK

### Checking a Feature Flag/Gate

Now that your SDK is initialized, let's fetch a [**Feature Gate**](/feature-flags/overview). Feature Gates can be used to create logic branches in code that can be rolled out to different users from the Statsig Console. Gates are always **CLOSED** or **OFF** (think `return false;`) by default.

```rust
let user = StatsigUser::with_user_id("a-user".to_string());

if Statsig::check_gate(&user, "a_gate").ok().unwrap_or(false) {
    // Gate is on, enable new feature
} else {
    // Gate is off
}
```

### Reading a Dynamic Config

Feature Gates can be very useful for simple on/off switches, with optional but advanced user targeting. However, if you want to be able send a different set of values (strings, numbers, and etc.) to your clients based on specific user attributes, e.g. country, [**Dynamic Configs**](/dynamic-config) can help you with that.

```rust
let config = Statsig::get_config(&user, "a_config").ok().unwrap();
let value = config.get_string("a_key", "default_value");
```

### Getting a Layer/Experiment

Then we have **Layers/Experiments**, which you can use to run A/B/n experiments. We offer two APIs, but we recommend the use of [layers](/layers) to enable quicker iterations with parameter reuse.

```rust
let layer = Statsig::get_layer(&user, "a_layer").ok().unwrap();
let param_value = layer.get_string("a_parameter", "default_value");

// or via get_experiment
let experiment = Statsig::get_experiment(&user, "an_experiment").ok().unwrap();
let exp_value = experiment.get_string("a_parameter", "default_value");
```

### Logging an Event

Now that you have a Feature Gate or an Experiment set up, you may want to track some custom events and see how your new features or different experiment groups affect these events.

```rust
let event = StatsigEvent::new("event_name".to_string());
Statsig::log_event(&user, event);
```

## Statsig User

When calling APIs that require a user, you should pass as much information as possible in order to take advantage of advanced gate and config conditions (like country or OS/browser level checks), and correctly measure impact of your experiments on your metrics/events. At least one identifier, either userID or a Custom ID, is required to provide a consistent experience for a given user (as explained [here](/concepts/user#why-is-an-id-always-required-for-server-sdks)).

### Private Attributes

Have sensitive user PII data that should not be logged? No problem, we have a solution for it! On the StatsigUser object we also have a field called `privateAttributes`, which is a simple object/dictionary that you can use to set private user attributes. Any attribute set in `privateAttributes` will only be used for evaluation/targeting, and removed from any logs before they are sent to Statsig server.

## Shutdown

To gracefully shutdown the SDK and ensure all events are flushed:

```rust
Statsig::shutdown().await;
```


